package merkle.implementation;

import merkle.Configuration;
import merkle.IClient;
import merkle.IMerkleTree;

import java.util.List;

/**
 * TASK 2
 * TODO: IMPLEMENT verifyResponse
 *
 * @author Seungho Yang
 * @userid yang968
 * @pso 10
 * @date 10/28/2016
 */
public class Client extends IClient {

    /**
     * Given the path siblings this function has to verify if
     * the masterHash generated by concatenating and hashing
     * level by level is the same as <i>this.masterHash</i>
     * You can use <i>Configuration.hashFunction</i>
     */
    protected boolean verifyResponse(List<IMerkleTree.Node> pathSiblings) throws Exception {
        //TODO:implement
        boolean matched = false;
        /*
         * You need to use Configuration.hashFunction and this.masterHash to determine a match
         */
        // Edge test case where test node is root (happened once while testing)
        if (pathSiblings.size() == 1) {
            IMerkleTree.Node currentHash = new IMerkleTree.Node(Configuration.hashFunction.hashBlock(pathSiblings.get(0).getHash()), 0);
            return this.masterHash.equals(currentHash.getHash());
        }

        // Find hash value of the parent node from first two items in the list
        IMerkleTree.Node currentHash = new IMerkleTree.Node(
                Configuration.hashFunction.concatenateHash(pathSiblings.get(0), pathSiblings.get(1)), pathSiblings.get(0).getIndex() / 2);

        // Find hash value of the consecutive parent nodes
        for (int i = 2; i < pathSiblings.size(); i++) {
            if (currentHash.getType() == IMerkleTree.NodeType.left) {
                currentHash = new IMerkleTree.Node(Configuration.hashFunction.concatenateHash(currentHash, pathSiblings.get(i)), pathSiblings.get(i).getIndex() / 2);
            }
            else {
                currentHash = new IMerkleTree.Node(Configuration.hashFunction.concatenateHash(pathSiblings.get(i), currentHash), pathSiblings.get(i).getIndex() / 2);
            }
        }

        // return true/false based on masterHash == currentHash
        if (this.masterHash.equals(currentHash.getHash())) return true;
        return matched;
    }
}
