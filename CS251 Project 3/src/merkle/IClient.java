package merkle;


import merkle.implementation.MerkleTree;

import java.io.File;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

/**
 * This is the client
 * DO NOT UPLOAD THIS FILE
 */
public abstract class IClient {
    private IServer server;
    protected String masterHash;
    private int numberOfNodes;

    /**
     * This method simulates uploading a file to a server
     * 1 - The file is uploaded to the server
     * 2 - The merkle tree is built
     * 3- The master hash is recorded
     */
    IMerkleTree uploadFile(File file, IServer server) throws Exception {
        this.server = server;
        this.server.uploadFile(file);

        IMerkleTree merkleTree = new MerkleTree();
        this.masterHash = merkleTree.build(file);

        this.numberOfNodes = merkleTree.getNumberOfNodes();
        return merkleTree;
    }

    /**
     * This method takes the number of times verification is to be run as input
     * A randomly picked node is verified that many times
     */
    int verifyFile(int verifyCount) throws Exception {
        int result = 0;
        for (int i = 0; i < verifyCount; i++) {
            int testNode = ThreadLocalRandom.current().nextInt(2, numberOfNodes);
            List<IMerkleTree.Node> trace = this.server.generateResponse(testNode);
            boolean matched = verifyResponse(trace);
            result += matched ? 1 : 0;
            Configuration.println("Verification result for node " + testNode + " = " + matched);
        }
        return result;

    }

    /**
     * Given the path siblings this function has to verify if
     * the masterHash generated by concatenating and hashing
     * level by level is the same as <i>this.masterHash</i>
     * You can use <i>Configuration.hashFunction</i>
     */
    protected abstract boolean verifyResponse(List<IMerkleTree.Node> pathSiblings) throws Exception;
}
